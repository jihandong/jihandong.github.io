<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Introduction  在Lab2中,mem_init()函数设置了JOS内核的二级页表，但是对用户环境没有做处理，本次实验需要使用数据结构保护追踪用户环境，创建用户环境、加载program image，并执行。还要使JOS能够处理任何用户环境下的系统调用和异常。  PS：本次实验“环境（environment）”和“进程（process）”是等价的，两者都表示程序在运行时的抽象；本实验中使用">
<meta name="keywords" content="MIT6.828,OS">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828:assignment7:LAB3用户环境">
<meta property="og:url" content="http://yoursite.com/2019/06/28/mit6-828A7/index.html">
<meta property="og:site_name" content="JiHandong&#39;s Blog">
<meta property="og:description" content="Introduction  在Lab2中,mem_init()函数设置了JOS内核的二级页表，但是对用户环境没有做处理，本次实验需要使用数据结构保护追踪用户环境，创建用户环境、加载program image，并执行。还要使JOS能够处理任何用户环境下的系统调用和异常。  PS：本次实验“环境（environment）”和“进程（process）”是等价的，两者都表示程序在运行时的抽象；本实验中使用">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://yoursite.com/2019/06/28/mit6-828A7/envid_t.png">
<meta property="og:image" content="http://yoursite.com/2019/06/28/mit6-828A7/VirtualBox_saya_30_06_2019_02_45_17.png">
<meta property="og:updated_time" content="2019-07-04T03:44:01.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828:assignment7:LAB3用户环境">
<meta name="twitter:description" content="Introduction  在Lab2中,mem_init()函数设置了JOS内核的二级页表，但是对用户环境没有做处理，本次实验需要使用数据结构保护追踪用户环境，创建用户环境、加载program image，并执行。还要使JOS能够处理任何用户环境下的系统调用和异常。  PS：本次实验“环境（environment）”和“进程（process）”是等价的，两者都表示程序在运行时的抽象；本实验中使用">
<meta name="twitter:image" content="http://yoursite.com/2019/06/28/mit6-828A7/envid_t.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>MIT6.828:assignment7:LAB3用户环境</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Inicio</a></li>
         
          <li><a href="/about/">Acerca de</a></li>
         
          <li><a href="/archives/">Articulos</a></li>
         
          <li><a href="/projects_url">Proyectos</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/07/02/mit6-828A10/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/06/13/vim常用操作/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Post Anterior</span>
      <span id="i-next" class="info" style="display:none;">Post Siguiente</span>
      <span id="i-top" class="info" style="display:none;">Arriba</span>
      <span id="i-share" class="info" style="display:none;">Compartir Post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/06/28/mit6-828A7/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/06/28/mit6-828A7/&text=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/06/28/mit6-828A7/&is_video=false&description=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.828:assignment7:LAB3用户环境&body=Check out this article: http://yoursite.com/2019/06/28/mit6-828A7/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/06/28/mit6-828A7/&name=MIT6.828:assignment7:LAB3用户环境&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-A：用户环境和异常处理"><span class="toc-number">2.</span> <span class="toc-text">Part A：用户环境和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Environment-State"><span class="toc-number">2.1.</span> <span class="toc-text">Environment State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocating-the-Environments-Array"><span class="toc-number">2.2.</span> <span class="toc-text">Allocating the Environments Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Exercise1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-and-Running-Environments"><span class="toc-number">2.3.</span> <span class="toc-text">Creating and Running Environments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise2"><span class="toc-number">2.3.1.</span> <span class="toc-text">Exercise2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断-异常-Control-Transfer保护机制"><span class="toc-number">2.4.</span> <span class="toc-text">中断 异常 Control Transfer保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#An-Example"><span class="toc-number">2.5.</span> <span class="toc-text">An Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nested-Exceptions-and-Interrupts"><span class="toc-number">2.6.</span> <span class="toc-text">Nested Exceptions and Interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Setting-Up-the-IDT"><span class="toc-number">2.7.</span> <span class="toc-text">Setting Up the IDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise4"><span class="toc-number">2.7.1.</span> <span class="toc-text">Exercise4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#challenge"><span class="toc-number">2.8.</span> <span class="toc-text">challenge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Questions"><span class="toc-number">2.9.</span> <span class="toc-text">Questions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-B：Page-Fault（缺页），断点异常，系统调用"><span class="toc-number">3.</span> <span class="toc-text">Part B：Page Fault（缺页），断点异常，系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Page-Faults"><span class="toc-number">3.1.</span> <span class="toc-text">Handling Page Faults</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise5"><span class="toc-number">3.1.1.</span> <span class="toc-text">Exercise5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Breakpoint-Exception"><span class="toc-number">3.2.</span> <span class="toc-text">Breakpoint Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise6"><span class="toc-number">3.2.1.</span> <span class="toc-text">Exercise6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge"><span class="toc-number">3.2.2.</span> <span class="toc-text">Challenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Questtions"><span class="toc-number">3.2.3.</span> <span class="toc-text">Questtions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Calls"><span class="toc-number">3.3.</span> <span class="toc-text">System Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise7"><span class="toc-number">3.3.1.</span> <span class="toc-text">Exercise7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">Challenge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-mode-startup"><span class="toc-number">3.4.</span> <span class="toc-text">User-mode startup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise8"><span class="toc-number">3.4.1.</span> <span class="toc-text">Exercise8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Faults-and-Memory-Protection"><span class="toc-number">3.5.</span> <span class="toc-text">Page Faults and Memory Protection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise9"><span class="toc-number">3.5.1.</span> <span class="toc-text">Exercise9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise10"><span class="toc-number">3.5.2.</span> <span class="toc-text">Exercise10</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-A"><span class="toc-number">5.1.</span> <span class="toc-text">Part A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PartB"><span class="toc-number">5.2.</span> <span class="toc-text">PartB</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        MIT6.828:assignment7:LAB3用户环境
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">JiHandong's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-06-27T21:00:40.000Z" itemprop="datePublished">2019-06-28</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/MIT6-828/">MIT6.828</a>, <a class="tag-link" href="/tags/OS/">OS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  在Lab2中,<code>mem_init()</code>函数设置了JOS内核的二级页表，但是对用户环境没有做处理，本次实验需要使用数据结构保护追踪用户环境，创建用户环境、加载program image，并执行。还要使JOS能够处理任何用户环境下的系统调用和异常。<br>  PS：本次实验“环境（environment）”和“进程（process）”是等价的，两者都表示程序在运行时的抽象；本实验中使用术语“环境”只是为了和UNIX的“进程”区分。<br>  创建lab3分支，从lab2中merge过来，本次实验分AB两个部分，schedule上每个部分给予一周时间，同样需要完成所有的练习和至少一个challenge。可以使用<strong>内联汇编</strong>的语法。</p>
<h2 id="Part-A：用户环境和异常处理"><a href="#Part-A：用户环境和异常处理" class="headerlink" title="Part A：用户环境和异常处理"></a>Part A：用户环境和异常处理</h2><p>  阅读<code>inc/env.h</code>文件。<br>  其中数据结构envid_t可以表示一个环境，如图所示，后10位储存在<code>Env</code>中的index，即自己的座位号；而中间的21位是每个环境独一无二的ID；由于envid_t本质上是int，首位为0表示一个正数，如果为1表示为一个负数，对于envid_t负数被解读为错误。<br><img src="/2019/06/28/mit6-828A7/envid_t.png"></p>
<h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p>  阅读<code>inc/env.h</code>文件中定义的<code>struct Env</code>。每个成员都包含了一个环境的关键属性，比如page directory的地址、此环境的id（envid_t类型变量）、父环境</p>
<p>的id（envid_t类型变量）。</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>  Lab2中我们部署了pages线性表，这次来部署一下envs线性表。</p>
<h4 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Modify mem_init() in kern/pmap.c to allocate and map the envs array.</span><br><span class="line">This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array.</span><br><span class="line">Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.</span><br><span class="line">You should run your code and make sure check_kern_pgdir() succeeds.</span><br></pre></td></tr></table></figure>
<p>  <code>kern/pmap.c</code>中新include了<code>kern/env.h</code>，由<code>inc/env.h</code>的定义，我们知道10位用于在envs中的寻址，所以envs的长度为2^10；<code>envs</code>定义在<code>kern/env.c</code>中。<br>  这部分代码和Lab2中的对pages的分配大同小异，先使用<code>boot_alloc()</code>为envs准备空白的物理地址；随后建立二级页表对UENVS开始的一个PTSIZE进行map。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	envs = (struct Env*) boot_alloc(NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line">	<span class="built_in">memset</span>(pages, <span class="number">0</span>, NENV * <span class="keyword">sizeof</span>(struct Env));</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line">	<span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line">	<span class="comment">// Permissions:</span></span><br><span class="line">	<span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line">	<span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UENVS, NENV*<span class="keyword">sizeof</span>(struct Env),</span><br><span class="line">		PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure>
<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>  现在我们开始对<code>kern/env.c</code>编程，即我们开始编写运行用户环境的代码。<br>  <code>obj/Makefrag</code>中有一些能够将二进制文件像.o文件那样”link”起来的骚操作；obj/kern/kernel.sym中也能看到一些神奇的符号。<br>  <code>kern/init.c</code>中的<code>i386_init()</code>能够运行上面谈到的二进制image，然而我们还需要在Exercise2中编写设置用户环境的函数。</p>
<h4 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h4><p><strong>In the file env.c, finish coding the following functions:env_init()、env_setup_vm()、region_alloc()、load_icode()、env_create()、env_run()</strong><br>  首先了解一下各个函数的功能：<br>  <code>env_init()</code>初始化envs线性表中的全部Env结构，并全部加入env_free_list；<code>env_init_percpu()</code>能够为不同特权级别的段单独配置segmentation hardware；<br>  <code>env_setup_vm()</code>为新的环境分配page directory，并初始化其中的内核空间（不用用户环境的内核代码都映射且仅映射到同一个地方）；<br>  <code>region_alloc()</code>为新环境allocate长度为len的物理内存并map到环境的地址空间va位置，不需要初始化其中的内容；<br>  <code>load_icode()</code>解析ELF二进制image，加载到用户地址；<br>  <code>env_create()</code>创建新环境需要调用<code>env_alloc()</code>分配空间，调用<code>load_icode()</code>加载；<br>  <code>env_run()</code>以用户模式运行一个给出的环境；<br>  然后我们可以/编写代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(struct Env* e = envs+NENV<span class="number">-1</span>; e &gt;= envs; e--) &#123;</span><br><span class="line">		e-&gt;env_id = <span class="number">0</span>;</span><br><span class="line">		e-&gt;env_link = env_free_list;</span><br><span class="line">		env_free_list = e;	</span><br><span class="line">	&#125;</span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用户环境</span></span><br><span class="line"><span class="comment">// 需要复制kern_pgdir中内核部分的内容</span></span><br><span class="line"><span class="comment">// 其实直接全部复制就可以了，kern_pgdir的内容全是内存映射</span></span><br><span class="line"><span class="comment">// 只有UVPT需要单独设置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	p-&gt;pp_ref++;	</span><br><span class="line">	e-&gt;env_pgdir = (<span class="keyword">pde_t</span>*)KADDR(page2pa(p));</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为环境e分配len字节到虚拟地址va</span></span><br><span class="line"><span class="comment">// 使用page_insert更方便</span></span><br><span class="line"><span class="comment">// 有必要熟悉自己在前面实验中完成的函数工具，抽象分层已经做了，不用是自己吃亏</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>* begin = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">void</span>* end = ROUNDUP(va+len, PGSIZE);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span>(; begin &lt; end; begin += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(p = page_alloc(<span class="number">0</span>))) panic(<span class="string">"alloc page failed in region_alloc()\n"</span>);</span><br><span class="line">		page_insert(e-&gt;env_pgdir, p, begin, PTE_W | PTE_U);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载ELF可执行文件到环境e</span></span><br><span class="line"><span class="comment">// 需要注意几个要点</span></span><br><span class="line"><span class="comment">// 1、页表：需要使用lcr3()切换到环境e的页表，这样mem系列函数才能正常工作</span></span><br><span class="line"><span class="comment">// 2、起始地址：需要设置起始地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elfhdr</span> = (<span class="title">struct</span> <span class="title">Elf</span>*)<span class="title">binary</span>;</span></span><br><span class="line">	ph = (struct Proghdr *) (binary + elfhdr-&gt;e_phoff);</span><br><span class="line">	eph = ph + elfhdr-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">			region_alloc(e, (<span class="keyword">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memset</span>((<span class="keyword">void</span>*)ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="keyword">void</span>*)ph-&gt;p_va, binary+ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	region_alloc(e, (<span class="keyword">void</span>*)USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">	load_icode(e, binary);</span><br><span class="line">	e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	curenv = e;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">	e-&gt;env_runs++;</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  完成之后如果直接执行make qemu会因为进入用户模式而出现三重错误，正确的检查方式是在gdb模式下，将断点打在<code>boot/main.c</code>中<code>sys_cputs()</code>的int系统调用指令上，如果能顺利运行到该处，说明完成。<br><img src="/2019/06/28/mit6-828A7/VirtualBox_saya_30_06_2019_02_45_17.png"></p>
<h3 id="中断-异常-Control-Transfer保护机制"><a href="#中断-异常-Control-Transfer保护机制" class="headerlink" title="中断 异常 Control Transfer保护机制"></a>中断 异常 Control Transfer保护机制</h3><p>  在Exercise2中，程序在用户模式下走到了死胡同。我们需要建立基本的异常和系统调用处理机制，以实现内核从用户模式恢复控制权。<br>  在不同的架构和OS之间，exception、trap、 interrupt、 fault、abort都没有统一的精确定义，6.828大体参考Intel’s terminology。<br>  如果还没做好准备，阅读<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm" target="_blank" rel="noopener">Chapter 9, Exceptions and Interrupts</a></p>
<p>  中断和异常都会导致用户模式切换到内核模式。</p>
<ul>
<li>中断：受保护的控制转移，一般由外部I/O活动导致；</li>
<li>异常：同样是受保护的控制转移，一般由内部代码导致，比如除0；</li>
</ul>
<p>  保护由两个机制提供：</p>
<ul>
<li>IDT(Interrupt Descriptor Table)：中断描述表/中断矢量表，是一个handler程序的“目录”，保存有不同类型中断的处理程序入口地址（eip，cs）；</li>
<li>TSS(Task State Segment)：在终端/异常结束之前保存旧的处理器状态（一些重要寄存器的状态，比如eip，cs等）；</li>
</ul>
<p>  处理器<strong>内部异步异常</strong>的矢量为0~31，&gt;31的留作<strong>软件中断</strong>，使用int指令或由异步硬件外设生成。</p>
<h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p>  将上面有关中断和异常有关的知识点结合起来，讨论一个实例。<br>  假设我们在用户环境中执行代码，碰到了一个除0错误：</p>
<ol>
<li>处理器切换到TSS中SS0和ESP0指定的栈，JOS保持GD_KD和KSTACKTOP；</li>
<li><p>处理器将异常参数推入KSTACKTOP开始的内核栈；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>除0对应的中断矢量是0，访问IDT得到CS:EIP；</p>
</li>
<li><p>相应的handler得到控制权；</p>
<p>对于某些特定的异常可能还会推入一个error code，栈的结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20</span><br><span class="line">|     error code     |     &quot; - 24 &lt;---- ESP</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>  处理器在用户态和内核态都能接受异常，在后者情况下可以不切换栈；就不需要保存栈的环境，需要压栈的内容少了很多。这种异常被称作nested exception（嵌套异常）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>  经过上面的知识预备，我们可以开始设置IDT处理0-31的异常。<br>  <code>inc/trap.h</code>和<code>kern/trap.h</code>中包含对设计有用的重要声明。<br>  PS：0-31中有的标号本来就是Intel保留的，其永远不会被处理器生成。<br>  目标结构应该如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure></p>
<p>  每个异常/中断都应该在<code>trapentry.S</code>中有自己的handler，且<code>trap_init()</code>应能够用这些handlers初始化IDT。每个handler都应该在栈中创建一个struct Trapframe，并使用指向这个Trapframe的指针来调用<code>trap()</code>处理异常/中断。</p>
<h4 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Edit trapentry.S and trap.c and implement the features described above.下面是一些提示： </span><br><span class="line">	The macros TRAPHANDLER and TRAPHANDLER_NOEC in trapentry.S should help you, as well as the T_* defines in inc/trap.h.（提供的一些宏工具）</span><br><span class="line">	You will need to add an entry point in trapentry.S (using those macros) for each trap defined in inc/trap.h.（为每个trap添加entry point）</span><br><span class="line">	and you&apos;ll have to provide _alltraps which the TRAPHANDLER macros refer to.（?）</span><br><span class="line">	You will also need to modify trap_init() to initialize the idt to point to each of these entry points defined in trapentry.S; the SETGATE macro will be helpful here. （使用mmu.h中的SETGATE初始化IDT）</span><br><span class="line"></span><br><span class="line">_alltraps应该满足：</span><br><span class="line">	push values to make the stack look like a struct Trapframe</span><br><span class="line">	load GD_KD into %ds and %es</span><br><span class="line">	pushl %esp to pass a pointer to the Trapframe as an argument to trap()</span><br><span class="line">	call trap (can trap ever return?)</span><br><span class="line"></span><br><span class="line">考虑使用pushal指令，它完美地符合栈的布局。</span><br><span class="line"></span><br><span class="line">使用make grade测试，提供了几个会触发异常的函数。</span><br></pre></td></tr></table></figure>
<p>  认真阅读题目：</p>
<ol>
<li><code>kern/trapentry.S</code>中我们需要设置各handler的entry point具体可以用提供的两个宏来设置，两个分别用于有无error code的trap handler。之后所有的程序都要转到<code>_trapsall</code>标号处，完整地传入一个struct Trapframe作为参数（这里与xv6参考手册的设置不符合，不需要传入%fs和%gs作为参数，如果传入会导致trap类型的判断错误，应该以struct Trapframe为准）。</li>
<li><p><code>kern/trap.c</code>的<code>trap_init()</code>中我们需要设置IDT，使用的SETGATE宏可以通过<code>grep -rl</code>找到，根据其描述合理地设置传入参数，分条设置IDT；这里需要传入handler的entry point作为参数，通过在外面把标号作为函数名，进行一堆<strong>弱定义</strong>即可。<br> 最终<code>kern/trapentry.S</code>的新增内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(hdr0, T_DIVIDE) ;根据是否传入error code选择宏</span><br><span class="line">TRAPHANDLER_NOEC(hdr1, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(hdr2, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(hdr3, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(hdr4, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(hdr5, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(hdr6, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(hdr7, T_DEVICE)</span><br><span class="line">TRAPHANDLER(hdr8, T_DBLFLT)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER(hdr10, T_TSS)</span><br><span class="line">TRAPHANDLER(hdr11, T_SEGNP)</span><br><span class="line">TRAPHANDLER(hdr12, T_STACK)</span><br><span class="line">TRAPHANDLER(hdr13, T_GPFLT)</span><br><span class="line">TRAPHANDLER(hdr14, T_PGFLT)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(hdr16, T_FPERR)</span><br><span class="line">TRAPHANDLER(hdr17, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(hdr18, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(hdr19, T_SIMDERR)</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal				;不需要传入%fs,%gs</span><br><span class="line">	movw $GD_KD, %ax	;这里注意是16位寄存器</span><br><span class="line">	movw %ax, %ds</span><br><span class="line">	movw %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>而<code>kern/trap.c</code>为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr0</span><span class="params">()</span></span>;	<span class="comment">//弱符号会被链接到trapentry.S的强定义上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr3</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr4</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr5</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr6</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr7</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr8</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr10</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr11</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr12</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr13</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr14</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr16</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr17</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr18</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hdr19</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Yur code here.</span></span><br><span class="line">	<span class="comment">//struct Gatedesc, istrap, CS, offset, DPL</span></span><br><span class="line">	SETGATE(idt[T_DIVIDE],  <span class="number">1</span>, GD_KT, hdr0, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DEBUG],   <span class="number">1</span>, GD_KT, hdr1, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_NMI],     <span class="number">1</span>, GD_KT, hdr2, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_BRKPT],   <span class="number">1</span>, GD_KT, hdr3, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_OFLOW],   <span class="number">1</span>, GD_KT, hdr4, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_BOUND],   <span class="number">1</span>, GD_KT, hdr5, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ILLOP],   <span class="number">1</span>, GD_KT, hdr6, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DEVICE],  <span class="number">1</span>, GD_KT, hdr7, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DBLFLT],  <span class="number">1</span>, GD_KT, hdr8, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//9</span></span><br><span class="line">	SETGATE(idt[T_TSS],     <span class="number">1</span>, GD_KT, hdr10, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SEGNP],   <span class="number">1</span>, GD_KT, hdr11, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_STACK],   <span class="number">1</span>, GD_KT, hdr12, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_GPFLT],   <span class="number">1</span>, GD_KT, hdr13, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_PGFLT],   <span class="number">1</span>, GD_KT, hdr14, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//15</span></span><br><span class="line">	SETGATE(idt[T_FPERR],   <span class="number">1</span>, GD_KT, hdr16, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ALIGN],   <span class="number">1</span>, GD_KT, hdr17, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_MCHK],    <span class="number">1</span>, GD_KT, hdr18, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SIMDERR], <span class="number">1</span>, GD_KT, hdr19, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止make grade应该能得到Part A的满分。</p>
</li>
</ol>
<h3 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完成Exercise4得到了一堆冗长的代码，between the lists of TRAPHANDLER in trapentry.S and their installations in trap.c</span><br><span class="line">为了更加优雅，可以修改trapentry.S的宏来自动生成trap.c的table。</span><br><span class="line">Note that you can switch between laying down code and data in the assembler by using the directives .text and .data.</span><br></pre></td></tr></table></figure>
<p>  to be continued</p>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Question1:</span><br><span class="line">为什么要为每个exception/interrupt设置单独的handler函数?</span><br><span class="line">如果所有exceptions/interrupts都被传送到同一个handler，我们应该提供什么特性？</span><br></pre></td></tr></table></figure>
<p>  不同的trap 需要的操作不一样，handler自然也不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Question2:</span><br><span class="line">为了使得user/softint正常工作需要做什么？</span><br><span class="line">grade script期待其产生一个general protection fault(trap 13)，但是softint的代码说了int $14；为什么这会产生trap 13。</span><br><span class="line">如果内核真的允许int $14去invoke内核的page fault handler(trap 14)会怎么样？</span><br></pre></td></tr></table></figure>
<p>  理论上<strong>不会导致其他exception的protection vialation</strong>都会触发general protection（13号）。目前14号handler的访问权限是0（最高权限），用户态只有权限3，无法问，这种行为会先触发13号trap。</p>
<h2 id="Part-B：Page-Fault（缺页），断点异常，系统调用"><a href="#Part-B：Page-Fault（缺页），断点异常，系统调用" class="headerlink" title="Part B：Page Fault（缺页），断点异常，系统调用"></a>Part B：Page Fault（缺页），断点异常，系统调用</h2><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>  14。<br>  发生page fault后会在特定寄存器CR2保存linear addr，使用<code>page_fault_handler()</code>处理这个错误。</p>
<h4 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改trap_dispatch()，实现dispatch fault expection to page_fault_handler()。</span><br><span class="line">之后将能够在make grade中通过faultread,faultkernel,faultwrite,faultwritekernel测试。</span><br><span class="line">可以使用make run-x或make run-x-nox使JOS进入特定的用户程序，x可以替换为hello。</span><br><span class="line">之后我们会在实现system calls的时候实现真正的page fault处理。</span><br></pre></td></tr></table></figure>
<p>  非常简单，我们分析一下函数及其调用关系，经过Exercise4我们知道当出现错误之后，会调用<code>trap()</code>函数其中我们看到最后调用<code>trap_dispatch()</code>来handle错误，所以我们需要在dispatch中调用handler来处理错误，此处暂时只要求我们handle page fault，所以加上简单的一行即可；不难想象之后还要添加其他结构类似的判断行。<br>  以下为暂时的<code>trap_dispatch()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(tf-&gt;tf_trapno == T_PGFLT) page_fault_handler(tf);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面是没有被handle的错误，这说明kernel有bug，是不允许的</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Breakpoint-Exception"><a href="#Breakpoint-Exception" class="headerlink" title="Breakpoint Exception"></a>Breakpoint Exception</h3><p>  3号。<br>  JOS中我们要小小地滥用一下它，将其作为调用kernel monitor的pseudo-system call（panic就是用这个实现的）。</p>
<h4 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改trap_dispatch()使breakpoint exeption能够invoke kernel monitor。</span><br><span class="line">So far，make grade should pass breakpoint test.</span><br></pre></td></tr></table></figure>
<p>  与Exercise5中相同，需要添加T_BRKPT的处理条目，我们将其改写为switch格式以准备后续添加；这里需要调用的是<code>kern/monitor</code>中的<code>monitor()</code>函数，该函数可以传入一个struct Trapframe*作为参数。<br>  如果只完成上面的内容还不够，make grade会发现触发的不是3号trap，而是13号trap；即general protection，这个问题在Question3中解答，总而言之需要修改IDT的3号entry。<br>  这是修改后的<code>trap_dispatch()</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">		<span class="keyword">case</span> T_BRKPT: <span class="comment">//3</span></span><br><span class="line">			monitor(tf); <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">case</span> T_PGFLT: <span class="comment">//14</span></span><br><span class="line">			page_fault_handler(tf); <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// Unexpected trap: user process or kernel has a bug.</span></span><br><span class="line">			print_trapframe(tf);</span><br><span class="line">			<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">				panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				env_destroy(curenv);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modify kernel monitor使得可以“继续执行”（int 3之后）</span><br><span class="line">如此做可以实现single-step（单步调试）。</span><br><span class="line">要实现这个功能需要了解EFLAGS。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可选：</span><br><span class="line">If you&apos;re feeling really adventurous（你这个开头有点吓人啊）</span><br><span class="line">找一些x86 disassembler源码，想办法给JOS kernel monitor提供单步调试时disamssemble并display指令的功能。（果然吓人）</span><br><span class="line">将这个与Lab1中的符号表loading结合，就实现了一个真正的kernel debugger。</span><br></pre></td></tr></table></figure>
<h4 id="Questtions"><a href="#Questtions" class="headerlink" title="Questtions"></a>Questtions</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Question3:</span><br><span class="line">breakpoint test可能生成brekpoint exception或者general protection。</span><br><span class="line">这取决于你如何初始化IDT的break point entry，为什么？</span><br><span class="line">如何设置才能避免除法general protection。</span><br></pre></td></tr></table></figure>
<p>  在Question2中已经讨论过，这是用户权限不足导致的，所以只要把IDT中的3号entry的权限设置为用户态的3即可，这样用户也有权限使用int 3。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Question4:</span><br><span class="line">你认为这些机制的关键是什么？（尤其注意user/softint test)</span><br></pre></td></tr></table></figure></p>
<p>  to be continued</p>
<h3 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h3><p>  用户进程需要内核帮忙做一些事情的时候就会使用system call，这时user和kernel会合作保存一些状态，然后进入内核态执行一些代码。我们需要学习的是：</p>
<ol>
<li>如何得到内核的注意？</li>
<li><p>如何确定是那种系统调用？</p>
<p>JOS中使用int $0x30表示系统调用，需要在IDT中添加该条目，使用的标号为T_SYSCALL，允许用户使用。<br>system call的参数直接保存在寄存器中，如此做就不需要在用户环境栈或者instruction stream中找参数了。system call的调用号放在%eax寄存器中，最多5个参数分别放在 %edx、%ecx、%ebx、%edi、和%esi中，返回值一般放在%eax中，<code>lib/syscall.c</code>中的<code>syscall()</code>写有invoke system call的方法。</p>
<h4 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a>Exercise7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加T_SYSCALL条目：</span><br><span class="line">编辑kern/trapentry.S和kern/trap.c中的trap_init()。</span><br><span class="line">修改trap_dispatch()以handle system call interrupt，调用kern/syscall()，并将返回值通过%eax传回到用户进程。</span><br><span class="line"></span><br><span class="line">完整实现kern/syscall()，保证sysrtem call number valid时返回-E_INVAL。</span><br><span class="line">一定要完整地阅读syscall()的代码</span><br><span class="line">处理inc/syscall.h中列出的所有系统调用，invoke相应的kernel fuction即可。</span><br><span class="line"></span><br><span class="line">使用make run-hello验证正确，现在应该能够正确地在console打印出&quot;hello world&quot;，并在user mode引发一个page fault。</span><br><span class="line">同时make grade中的testbss也应该能够成功。</span><br></pre></td></tr></table></figure>
<p>要分析<code>lib/syscall.c</code>中的<code>syscall()</code>函数，首先要了解内联汇编和inline关键字<br>inline关键字用在函数名前，这种函数没有调用开销，其代码内容会跟随函数名一起进符号表，在调用的时候像宏一样临时展开；带来的一个好处是可以重定义该函数而不会发生链接错误，将inline函数定义在.h文件中时，相当于每个将其include的.c文件都得到了它的一个副本。<br>在<code>kern/trap.c</code>中，只需要在IDT中添加syscall的条目，并在<code>trap_dispatch()</code>中添加合适的条目即可，由于inline syscall()已经严格定义了函数<code>syscall()</code>的寄存器设置（这里的判断错误了，正确的实现在Exercise8中指出），所以除了传递参数之外没有什么我们需要做的工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增的IDT条目</span></span><br><span class="line">	SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, hdr48, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//最新的trap_dispatch()函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">		<span class="keyword">case</span> T_BRKPT: <span class="comment">//3</span></span><br><span class="line">			monitor(tf); <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">case</span> T_PGFLT: <span class="comment">//14</span></span><br><span class="line">			page_fault_handler(tf); <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">case</span> T_SYSCALL: <span class="comment">//48</span></span><br><span class="line">			syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">				tf-&gt;tf_regs.reg_edx,</span><br><span class="line">				tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">				tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">				tf-&gt;tf_regs.reg_edi,</span><br><span class="line">				tf-&gt;tf_regs.reg_esi);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// Unexpected trap: user process or kernel has a bug.</span></span><br><span class="line">			print_trapframe(tf);</span><br><span class="line">			<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">				panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				env_destroy(curenv);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kern/syscall.c</code>中，只要根据不同的syscall number调用不同的处理函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="keyword">char</span>*)a1, a2);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			<span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h4><p>  to be continued</p>
<h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>  用户程序在<code>lib/entry.S</code>的顶部开始运行，调用<code>lib/libmain.c</code>中的<code>libmain()</code>，将其modify来初始化指向envs中当前环境的全局指针thisenv。（Hint：阅读<code>inc/env.h</code>并使用<code>sys_getenvid()</code>）<br>  <code>libmain()</code>之后调用umain（对于hello是user/hello.c）。打印完毕之后会尝试访问thisenv-&gt;env_id，导致错误。（如果完成练习之后仍然错误，应该是没有将UENVS设置为可读）</p>
<h4 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在user library添加合适的代码。</span><br><span class="line">启动内核理论上可以看到&quot;hello, world&quot; and then print &quot;i am environment 00001000&quot;. user/hello</span><br><span class="line">之后会尝试调用sys_env_destroy()摧毁唯一的用户环境，进入kernel monitor</span><br><span class="line">So far，make grade应该可以通过hello test。</span><br></pre></td></tr></table></figure>
<p>  这个练习非常简单，根据提示只要简单地添加一行即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = envs + ENVX(sys_getenvid())</span><br></pre></td></tr></table></figure></p>
<p>  <code>ENVX()</code>是<code>inc/env.h</code>提供的宏，可以取得envid_t的后10位，即其在envs中的index。<br>  但是这个Exercise是前面问题集中暴露的地方，前面的内容有的虽然可以通过make grade，但是未必正确。就我个人而言，由于对Trapframe的功能和使用方式还不够了解，其实Exercise7的功能并未实现：<br>  最终我<strong>其实没有将syscall的返回值放在%eax</strong>，inline函数并不能限制返回值放在哪里，我应该做的是<strong>将返回值写回到Trapframe的eax中</strong>，如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">	tf-&gt;tf_regs.reg_edx,</span><br><span class="line">	tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">	tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">	tf-&gt;tf_regs.reg_edi,</span><br><span class="line">	tf-&gt;tf_regs.reg_esi);</span><br></pre></td></tr></table></figure></p>
<p>  犯下这样可笑的错误，是对trap机制不熟悉导致的！<br>  到目前为止，我们可以<strong>阶段总结一下trap handle的机制</strong>，exception/interrupt由机器产生，在IDT中选择合适的条目进入相应的handler，我们在<code>kern/trapentry.S</code>中为这些handler设置了entry point，在这里我们以struct Trapframe的格式保存了寄存器环境等信息，然后调用<code>kern/trap.c</code>中的<code>trap()</code>处理trap，其中根据trapno的不同使用<code>trap_dispatch()</code>调用不同的处理函数来解决这些trap，其中涉及到用户通过寄存器传递参数，应该通过struct Trapframe来接受用户的参数并返回；完成之后<code>trap()</code>会通过<code>env_run()</code>回到原环境，将Trapframe的寄存器内容pop出来。</p>
<h3 id="Page-Faults-and-Memory-Protection"><a href="#Page-Faults-and-Memory-Protection" class="headerlink" title="Page Faults and Memory Protection"></a>Page Faults and Memory Protection</h3><p>  system call给memory protection带来了有趣的问题：很多system call要求向kernel 传递（指向user buffer的）指针，内核将其dereference时有一些问题：</p>
<ol>
<li>可能被吓到，如果传递过来的位置导致page fault，应该把它当成user的page fault，而不是kernel的page fault（后者是会导致整个内核panic的严重问题）；</li>
<li><p>可能被利用，可能用户没有访问这个位置的权限，所以想通过kernel达成某些邪恶目的。</p>
<p>所以Kernel处理user给的指针要慎之又慎，接下来的Exercise使用了一种机制来解决上面的问题，即检查传递过来的指针指向的用户memory space，其page table是否允许这种内存操作。</p>
<h4 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">改变kern/trap.c，在kern mode page fault时panic。</span><br><span class="line">（Hint：通过检查tf_cs的低位判断kernel mode/user mode）</span><br><span class="line">阅读kern/pmap.c中的user_mem_assert，实现user_mem_check()</span><br><span class="line">修改kern/syscall.c使之对system calls进行sanity check</span><br><span class="line">So far，运行user/buggyhello应该可以看到环境被破坏，内核不会panic，效果如下：</span><br><span class="line"></span><br><span class="line">	[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">	[00001000] free env 00001000</span><br><span class="line">	Destroyed the only environment - nothing more to do!</span><br><span class="line">	</span><br><span class="line">最终，改变kern/kdebug.c中的debuginfo_eip，to call user_mem_check on usd, stabs, and stabstr</span><br><span class="line">运行user/breakpoint，使用backtrace，应该可以在page fault之前看到进入lib/libmain.c。什么导致了page fault？</span><br></pre></td></tr></table></figure>
<p><code>kern/trap.c</code>中只需要简单处理kernel page falut<br><code>kern/pamp.c</code>中需要补全函数<code>user_mem_check()</code>，这个函数检查一段内存范围内的权限，之前编写过类似的程序<br><code>kern/syscall.c</code>中需要在<code>sys_cputs()</code>位置进行sanity check</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(tf-&gt;tf_cs == GD_KT) panic(<span class="string">"kernel page fault\n"</span>);</span><br><span class="line">	</span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/pmap.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(va + len &gt; (<span class="keyword">void</span>*)ULIM) &#123;</span><br><span class="line">		<span class="keyword">if</span>(va &gt; (<span class="keyword">void</span>*)ULIM) user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">		<span class="keyword">else</span> 				user_mem_check_addr = ULIM;</span><br><span class="line">		<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span>* begin = (<span class="keyword">void</span>*)ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">void</span>* end = (<span class="keyword">void</span>*)ROUNDUP(va+len, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">void</span>* now = begin; now &lt; end; now += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">pte_t</span>* pt = KADDR(PTE_ADDR(env-&gt;env_pgdir[PDX(now)]));</span><br><span class="line">		<span class="keyword">if</span>((pt[PTX(now)] &amp; perm) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(now == begin) user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">			<span class="keyword">else</span>			user_mem_check_addr = (<span class="keyword">uintptr_t</span>)now;</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/syscall.c</span></span><br><span class="line">vstatic <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	user_mem_assert(curenv, (<span class="keyword">void</span>*)s, len, PTE_U);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boot kernel，run user/evilhello，环境应该被摧毁，kernel不应该panic，应该可以看到下面效果：</span><br><span class="line"></span><br><span class="line">	[00000000] new env 00001000</span><br><span class="line">	...</span><br><span class="line">	[00001000] user_mem_check assertion failure for va f010000c</span><br><span class="line">	[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>  什么都不用干，就是提醒你当访问地址超出ULIM的时候也要记得设置user_mem_check_addr。<br>  至此Lab3结束（接下来是schedule 3 weeks的Lab4）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab3/" target="_blank" rel="noopener">2018,mit6.828,Lab3</a><br><a href="https://www.jianshu.com/p/f67034d0c3f2" target="_blank" rel="noopener">博客文章1</a><br><a href="https://www.jianshu.com/p/f67034d0c3f2" target="_blank" rel="noopener">另一篇博客文章</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h3><ol>
<li>对于卡壳：如果卡壳太久了还是看别人博客比较好：最后的一点小bug往往很久才能查出，即使自己发现也难以得到很大收获，性价比太低。以后做Exercise应该在心中有一个时间安排，超时100%时应该及时放弃。</li>
<li>审题：认真阅读题目需求和提示，磨刀不误砍柴功；写下操作计划再开始编程和测试（或者把题目完整翻译/抄一遍也行，关键是搞清楚到底要干啥）。</li>
<li>准备：明明是学校汇（BAO）编（GAO）课上就应该熟练的东西，现在还是不太熟练（关键是要想清楚到底要怎么干）。</li>
<li>意外收获：做实验之外还发现了virtualbox可以多监视器（显示器），但是没有安装图形界面似乎不能直接支持这个功能？对vim的virsul模式和<code>.</code>重复指令更加熟练了，新了解了大小写转换的一些指令。</li>
</ol>
<h3 id="PartB"><a href="#PartB" class="headerlink" title="PartB"></a>PartB</h3><ol>
<li>阶段总结：需要适时总结一下完成的内容，搞清楚自己完成了什么，在做什么，还需要做什么（我在说什么废话啊）</li>
<li>额外知识：inline关键字和内联AT&amp;T汇编。</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Inicio</a></li>
         
          <li><a href="/about/">Acerca de</a></li>
         
          <li><a href="/archives/">Articulos</a></li>
         
          <li><a href="/projects_url">Proyectos</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-A：用户环境和异常处理"><span class="toc-number">2.</span> <span class="toc-text">Part A：用户环境和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Environment-State"><span class="toc-number">2.1.</span> <span class="toc-text">Environment State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocating-the-Environments-Array"><span class="toc-number">2.2.</span> <span class="toc-text">Allocating the Environments Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Exercise1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-and-Running-Environments"><span class="toc-number">2.3.</span> <span class="toc-text">Creating and Running Environments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise2"><span class="toc-number">2.3.1.</span> <span class="toc-text">Exercise2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断-异常-Control-Transfer保护机制"><span class="toc-number">2.4.</span> <span class="toc-text">中断 异常 Control Transfer保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#An-Example"><span class="toc-number">2.5.</span> <span class="toc-text">An Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nested-Exceptions-and-Interrupts"><span class="toc-number">2.6.</span> <span class="toc-text">Nested Exceptions and Interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Setting-Up-the-IDT"><span class="toc-number">2.7.</span> <span class="toc-text">Setting Up the IDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise4"><span class="toc-number">2.7.1.</span> <span class="toc-text">Exercise4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#challenge"><span class="toc-number">2.8.</span> <span class="toc-text">challenge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Questions"><span class="toc-number">2.9.</span> <span class="toc-text">Questions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-B：Page-Fault（缺页），断点异常，系统调用"><span class="toc-number">3.</span> <span class="toc-text">Part B：Page Fault（缺页），断点异常，系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Page-Faults"><span class="toc-number">3.1.</span> <span class="toc-text">Handling Page Faults</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise5"><span class="toc-number">3.1.1.</span> <span class="toc-text">Exercise5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Breakpoint-Exception"><span class="toc-number">3.2.</span> <span class="toc-text">Breakpoint Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise6"><span class="toc-number">3.2.1.</span> <span class="toc-text">Exercise6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge"><span class="toc-number">3.2.2.</span> <span class="toc-text">Challenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Questtions"><span class="toc-number">3.2.3.</span> <span class="toc-text">Questtions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Calls"><span class="toc-number">3.3.</span> <span class="toc-text">System Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise7"><span class="toc-number">3.3.1.</span> <span class="toc-text">Exercise7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">Challenge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-mode-startup"><span class="toc-number">3.4.</span> <span class="toc-text">User-mode startup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise8"><span class="toc-number">3.4.1.</span> <span class="toc-text">Exercise8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Faults-and-Memory-Protection"><span class="toc-number">3.5.</span> <span class="toc-text">Page Faults and Memory Protection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise9"><span class="toc-number">3.5.1.</span> <span class="toc-text">Exercise9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise10"><span class="toc-number">3.5.2.</span> <span class="toc-text">Exercise10</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Part-A"><span class="toc-number">5.1.</span> <span class="toc-text">Part A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PartB"><span class="toc-number">5.2.</span> <span class="toc-text">PartB</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/06/28/mit6-828A7/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/06/28/mit6-828A7/&text=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/06/28/mit6-828A7/&is_video=false&description=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.828:assignment7:LAB3用户环境&body=Check out this article: http://yoursite.com/2019/06/28/mit6-828A7/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/06/28/mit6-828A7/&title=MIT6.828:assignment7:LAB3用户环境"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/06/28/mit6-828A7/&name=MIT6.828:assignment7:LAB3用户环境&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Compartir</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 jihandong
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Inicio</a></li>
         
          <li><a href="/about/">Acerca de</a></li>
         
          <li><a href="/archives/">Articulos</a></li>
         
          <li><a href="/projects_url">Proyectos</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
