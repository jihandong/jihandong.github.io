<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Introduction  上个LAB实现了用户环境，这个LAB实现抢占式多任务处理。  PartA：为JOS添加multiprocessor支持，实现round-robin scheduling，添加基本的环境管理system call（creat/destroy环境，allocate/map内存）  PartB：实现一个Unix-likefork()（user-mode环境可以创建自己的拷贝）">
<meta name="keywords" content="MIT6.828,OS">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828:assignment10:LAB4抢占式多任务">
<meta property="og:url" content="http://yoursite.com/2019/07/02/mit6-828A10/index.html">
<meta property="og:site_name" content="JiHandong&#39;s Blog">
<meta property="og:description" content="Introduction  上个LAB实现了用户环境，这个LAB实现抢占式多任务处理。  PartA：为JOS添加multiprocessor支持，实现round-robin scheduling，添加基本的环境管理system call（creat/destroy环境，allocate/map内存）  PartB：实现一个Unix-likefork()（user-mode环境可以创建自己的拷贝）">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2019-07-09T06:42:17.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.828:assignment10:LAB4抢占式多任务">
<meta name="twitter:description" content="Introduction  上个LAB实现了用户环境，这个LAB实现抢占式多任务处理。  PartA：为JOS添加multiprocessor支持，实现round-robin scheduling，添加基本的环境管理system call（creat/destroy环境，allocate/map内存）  PartB：实现一个Unix-likefork()（user-mode环境可以创建自己的拷贝）">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>MIT6.828:assignment10:LAB4抢占式多任务</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/07/03/算法笔记part1/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/06/28/mit6-828A7/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Post Anterior</span>
      <span id="i-next" class="info" style="display:none;">Post Següent</span>
      <span id="i-top" class="info" style="display:none;">Adalt</span>
      <span id="i-share" class="info" style="display:none;">Compartir Post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/07/02/mit6-828A10/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/07/02/mit6-828A10/&text=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/07/02/mit6-828A10/&is_video=false&description=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.828:assignment10:LAB4抢占式多任务&body=Check out this article: http://yoursite.com/2019/07/02/mit6-828A10/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/07/02/mit6-828A10/&name=MIT6.828:assignment10:LAB4抢占式多任务&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartA-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="toc-number">2.</span> <span class="toc-text">PartA Multiprocessor Support and Cooperative Multitasking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiprocessor-Support"><span class="toc-number">2.1.</span> <span class="toc-text">Multiprocessor Support</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise1"><span class="toc-number">2.1.1.</span> <span class="toc-text">Exercise1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise2"><span class="toc-number">2.1.2.</span> <span class="toc-text">Exercise2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Question"><span class="toc-number">2.1.3.</span> <span class="toc-text">Question</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise3"><span class="toc-number">2.1.4.</span> <span class="toc-text">Exercise3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise4"><span class="toc-number">2.1.5.</span> <span class="toc-text">Exercise4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise5"><span class="toc-number">2.1.6.</span> <span class="toc-text">Exercise5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Question-1"><span class="toc-number">2.1.7.</span> <span class="toc-text">Question</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Round-Robin-Scheduling"><span class="toc-number">2.2.</span> <span class="toc-text">Round-Robin Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise6"><span class="toc-number">2.2.1.</span> <span class="toc-text">Exercise6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Calls-for-Environment-Creation"><span class="toc-number">2.3.</span> <span class="toc-text">System Calls for Environment Creation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise7"><span class="toc-number">2.3.1.</span> <span class="toc-text">Exercise7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartB-Copy-on-Write-Fork"><span class="toc-number">3.</span> <span class="toc-text">PartB Copy-on-Write Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#User-level-page-fault-handling"><span class="toc-number">3.1.</span> <span class="toc-text">User-level page fault handling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise8"><span class="toc-number">3.1.1.</span> <span class="toc-text">Exercise8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise9"><span class="toc-number">3.1.2.</span> <span class="toc-text">Exercise9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise10"><span class="toc-number">3.1.3.</span> <span class="toc-text">Exercise10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise11"><span class="toc-number">3.1.4.</span> <span class="toc-text">Exercise11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementing-Copy-on-Write-Fork"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing Copy-on-Write Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise12"><span class="toc-number">3.2.1.</span> <span class="toc-text">Exercise12</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartC-Preemptive-Multitasking-and-IPC"><span class="toc-number">4.</span> <span class="toc-text">PartC Preemptive Multitasking and IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clock-Interrupts-and-Preemption"><span class="toc-number">4.1.</span> <span class="toc-text">Clock Interrupts and Preemption</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise13"><span class="toc-number">4.1.1.</span> <span class="toc-text">Exercise13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise14"><span class="toc-number">4.1.2.</span> <span class="toc-text">Exercise14</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inter-Process-communication-IPC"><span class="toc-number">4.2.</span> <span class="toc-text">Inter-Process communication (IPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise15"><span class="toc-number">4.2.1.</span> <span class="toc-text">Exercise15</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        MIT6.828:assignment10:LAB4抢占式多任务
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">JiHandong's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-07-02T12:20:02.000Z" itemprop="datePublished">2019-07-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/MIT6-828/">MIT6.828</a>, <a class="tag-link" href="/tags/OS/">OS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>  上个LAB实现了用户环境，这个LAB实现抢占式多任务处理。<br>  PartA：为JOS添加multiprocessor支持，实现round-robin scheduling，添加基本的环境管理system call（creat/destroy环境，allocate/map内存）<br>  PartB：实现一个Unix-like<code>fork()</code>（user-mode环境可以创建自己的拷贝）<br>  PartC：添加对inter-process communication（IPC，进程间通信）的支持，使不同用户环境通信同步，同时支持hardware clock的中断和抢占。</p>
<h2 id="PartA-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#PartA-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="PartA Multiprocessor Support and Cooperative Multitasking"></a>PartA Multiprocessor Support and Cooperative Multitasking</h2><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>  目标是实现symmetric multiprocessing（SMP，对称多处理）。<br>  SMP中所有的CPU视作相同，共享计算机资源；但是在启动阶段，将他们分成两类：</p>
<ol>
<li>bootstrap processor（BSP），负责初始化和引导OS；</li>
<li>application processor（APs），在OS运行之后由BSP激活，具体使用哪个BSP由硬件和BIOS决定。<br> SMP系统中，每个CPU都有附带的local APIC unit（LAPIC），其负责在整个系统中提供中断，并提供唯一的标识符，本实验中使用LAPIC的如下基本功能：</li>
</ol>
<ul>
<li>使用<code>cpunum()</code>阅读LAPIC ID判断正在运行的CPU</li>
<li>使用<code>lapic_startap()</code>从BSP向APs发送中断（IPI）以启动其他CPU</li>
<li><p>使用<code>apic_init()</code>编写LAPIC的内置定时器触发时钟中断，以支持抢占式多任务</p>
<p>处理器通过memory-mapped I/O（MMIO）访问LAPIC，MMIO中有一部分直接硬链接到physical memory，所以可以使用原本访问内存的load/store instruction访问I/O device寄存器， （如：物理地址0xA0000有一个I/O hole，准备给VGA）LAPIC位于物理地址0xFE000000（32MB short of 4GB），JOS在MMIOBASE有一个4MB的gap， 后面的实验会介绍更多的MMIO regions，现在需要编写一个simple function to allocate space from this region and map device memory to it.</p>
</li>
</ul>
<h4 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现kern/pmap.c中的mmio_map_region()。</span><br><span class="line">kern/lapic.c中lapic_init的开头有显示如何使用这个函数</span><br><span class="line">You&apos;ll have to do the next exercise, too, before the tests for mmio_map_region will run.</span><br></pre></td></tr></table></figure>
<p>  使用类似<code>boot_alloc()</code>的编程，比较简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(base + size &gt; MMIOLIM)</span><br><span class="line">		panic(<span class="string">"mmio_map_region(): overflow MMIOLIM\n"</span>);</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa, PTE_W  | PTE_PCD | PTE_PWT);</span><br><span class="line">	<span class="keyword">void</span>* result = (<span class="keyword">void</span>*)base;	</span><br><span class="line">	<span class="keyword">if</span>(size &gt; <span class="number">0</span>) </span><br><span class="line">		base = ROUNDUP(base +size, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Read boot_aps() and mp_main() in kern/init.c, and the assembly code in kern/mpentry.S.</span><br><span class="line">Make sure you understand the control flow transfer during the bootstrap of APs. </span><br><span class="line">Then modify your implementation of page_init() in kern/pmap.c to avoid adding the page at MPENTRY_PADDR to the free list,</span><br><span class="line">so that we can safely copy and run AP bootstrap code at that physical address.</span><br><span class="line">Your code should pass the updated check_page_free_list() test.</span><br><span class="line">(but might fail the updated check_kern_pgdir() test, which we will fix soon).</span><br></pre></td></tr></table></figure>
<p>  <code>boot_aps()</code>首先将<code>mpentry.S</code>的代码复制到虚拟地址MPENTRY_PADDR（这个物理页绝不能加入free_list），之后就可按顺序boot一个又一个AP，每次都会等待唤醒信号传回。<br>  <code>kern/mpentry.S</code>打开分页之后AP进入保护模式，之后调用<code>mp_main()</code>。<br>  <code>kern/page_init()</code>只需要添加一行，增加page_busy的可能条件即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page_busy = page_busy ||</span><br><span class="line">	(i*PGSIZE == MPENTRY_PADDR);</span><br></pre></td></tr></table></figure></p>
<p>  在这里发现git merg Lab3时发生了冲突，因为<code>trap_dispatch()</code>修改了原有代码，导致需要手动处理冲突。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Question1</span><br><span class="line">Compare kern/mpentry.S side by side with boot/boot.S.</span><br><span class="line">Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel,</span><br><span class="line">what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S?</span><br><span class="line">In other words, what could go wrong if it were omitted in kern/mpentry.S?</span><br><span class="line">Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</span><br></pre></td></tr></table></figure>
<p>  MPBOOTPHYS计算出代码复制到位置MPENTRY_PADDR位置时s的物理地址。</p>
<h4 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Modify mem_init_mp() (in kern/pmap.c) to map per-CPU stacks starting at KSTACKTOP,</span><br><span class="line">as shown in inc/memlayout.h. </span><br><span class="line">The size of each stack is KSTKSIZE bytes plus KSTKGAP bytes of unmapped guard pages.</span><br><span class="line">Your code should pass the new check in check_kern_pgdir().</span><br></pre></td></tr></table></figure>
<p>  给每个CPU单独映射栈。<br>  只需要调用<code>boot_map_region()</code>就可以很方便地进行map。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">		boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE,</span><br><span class="line">		PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  再次被Lab2的自己坑了，经过debug找到了问题所在：之前编写的<code>boot_map_region()</code>有严重问题，居然在LAB4才暴露出问题。</p>
<h4 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The code in trap_init_percpu() (kern/trap.c) initializes the TSS and TSS descriptor for the BSP.</span><br><span class="line">It worked in Lab 3, but is incorrect when running on other CPUs.</span><br><span class="line">Change the code so that it can work on all CPUs.</span><br><span class="line">(Note: your new code should not use the global ts variable any more.)</span><br></pre></td></tr></table></figure>
<p>  每个cpu都需要单独初始化，所以我们应该使用thiscpu-&gt;cpu_ts取代原先的ts，并使用this-&gt;cpu_id取代文档中说明的i。<br>  难点在于找到当前CPU的TSS selector，我们只能从<code>inc/memlayout.h</code>中看到CPU0的GD_TSS0，其他的只能我们自己猜（微笑）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// when we trap to the kernel.</span></span><br><span class="line">	(thiscpu-&gt;cpu_ts).ts_esp0 = KSTACKTOP - thiscpu-&gt;cpu_id * (KSTKSIZE + KSTKGAP);</span><br><span class="line">	(thiscpu-&gt;cpu_ts).ts_ss0 = GD_KD;</span><br><span class="line">	(thiscpu-&gt;cpu_ts).ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">					<span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id].sd_s = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">	ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the IDT</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  又卡了一次bug，这次是exercise1不认真阅读要求导致的，debug进入关键代码发现似乎缺少写权限才发现的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">So far, run make qemu CPUS=4, you can see:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Physical memory: 66556K available, base = 640K, extended = 65532K</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br></pre></td></tr></table></figure></p>
<h4 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">big kernel lock 机制：只允许一个用户环境处于内核态</span><br><span class="line">You should apply the big kernel lock at four locations: </span><br><span class="line">In i386_init(), acquire the lock before the BSP wakes up the other CPUs.</span><br><span class="line">In mp_main(), acquire the lock after initializing the AP, and then call sched_yield() to start running environments on this AP.</span><br><span class="line">In trap(), acquire the lock when trapped from user mode. To determine whether a trap happened in user mode or in kernel mode, check the low bits of the tf_cs.</span><br><span class="line">In env_run(), release the lock right before switching to user mode. Do not do that too early or too late, otherwise you will experience races or deadlocks.</span><br><span class="line"></span><br><span class="line">Apply the big kernel lock as described above,</span><br><span class="line">by calling lock_kernel() and unlock_kernel() at the proper locations.</span><br></pre></td></tr></table></figure>
<p>  在四个地方插入函数调用即可。</p>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Question2</span><br><span class="line">It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time.</span><br><span class="line">Why do we still need separate kernel stacks for each CPU?</span><br><span class="line">Describe a scenario in which using a shared kernel stack will go wrong,</span><br><span class="line">even with the protection of the big kernel lock.</span><br></pre></td></tr></table></figure>
<p>  如果不同的CPU使用共享的栈，即使有big kernel lock也是绝对不行的。<br>  比如CPU1和CPU2，都要利用栈进行暂时存储；假如CPU1存进去了之后，立马被CPU2抢到了lock存入，CPU1又抢回lock，取出存入的值，就已经不是当初存进去的东西了，我们必须保护每个单独CPU的工作环境。</p>
<h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>  Round-Robin Scheduling有如下要点：</p>
<ul>
<li>调用<code>sched_yield()</code>选择一个环境去run，在envs里按顺序找到一个ENV_RUNNABLE的环境</li>
<li>绝不能两个CPU同时run一个环境：可以用status表示环境状态</li>
<li>环境可以通过调用<code>sched_yield()</code>主动让出CPU</li>
</ul>
<h4 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Implement round-robin scheduling in sched_yield() as described above.(kern/sched.c)</span><br><span class="line">Don&apos;t forget to modify syscall() to dispatch sys_yield().</span><br><span class="line"></span><br><span class="line">Make sure to invoke sched_yield() in mp_main.</span><br><span class="line"></span><br><span class="line">Modify kern/init.c to create three (or more!) environments that all run the program user/yield.c.</span><br></pre></td></tr></table></figure>
<p>  完成scheduler，实现时钟轮转作业，有个关键点是刚开机时，thiscpu尚未设置还为0，这个特殊情况需要单独判断，此外时钟轮转的次数应该为NENV-1次，这样会刚好回到原环境。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(curenv == <span class="number">0</span> || curenv == envs + NENV - <span class="number">1</span>)</span><br><span class="line">		idle = envs;</span><br><span class="line">	<span class="keyword">else</span> idle = curenv + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//after (NENV - 1) times, idle == curenv</span></span><br><span class="line">	<span class="keyword">while</span>(++counter &lt; NENV) &#123; </span><br><span class="line">		<span class="keyword">if</span>(idle-&gt;env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(idle);	<span class="comment">//do not return</span></span><br><span class="line">		<span class="keyword">if</span>(++idle == envs + NENV)</span><br><span class="line">			idle = envs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(idle-&gt;env_status == ENV_RUNNING) </span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// rerun by doing nothing</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sched_halt never returns</span></span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><h4 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a>Exercise7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Implement the system calls described above in kern/syscall.c and make sure syscall() calls them.</span><br><span class="line">You will need to use various functions in kern/pmap.c and kern/env.c, particularly envid2env().</span><br><span class="line">For now, whenever you call envid2env(), pass 1 in the checkperm parameter.</span><br><span class="line">Be sure you check for any invalid system call arguments, returning -E_INVAL in that case.</span><br><span class="line">Test your JOS kernel with user/dumb</span><br><span class="line">fork and make sure it works before proceeding.</span><br></pre></td></tr></table></figure>
<p>  本题工作量较大，需要实现新增的几个系统调用，这些系统调用中有一半以上的代码都在检查参数合理性，本身并不难实现。<br>  比较值得注意的是系统调用<code>sys_exofork</code>需要将子进程的返回值设置为0，如此做只需要将其tf_regs.reg_eax设置为0即可，因为我们知道系统调用的返回值会保存在eax寄存器中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;e-&gt;env_tf, &amp;curenv-&gt;env_tf, <span class="keyword">sizeof</span>(e-&gt;env_tf));</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>; <span class="comment">//return by eax</span></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span>(status &lt; ENV_FREE || status &gt; ENV_NOT_RUNNABLE) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(va &gt;= (<span class="keyword">void</span>*)UTOP</span><br><span class="line">		|| (perm &amp; PTE_U) == <span class="number">0</span></span><br><span class="line">		|| (perm &amp; ~PTE_U &amp; ~PTE_P &amp; ~PTE_AVAIL &amp; ~PTE_W) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;	<span class="comment">//check va, check perm</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;	<span class="comment">//check envid</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">p</span> = <span class="title">page_alloc</span>(1);</span></span><br><span class="line">	<span class="keyword">if</span>(!p) <span class="keyword">return</span> -E_NO_MEM;	<span class="comment">//check new page</span></span><br><span class="line">	r = page_insert(e-&gt;env_pgdir, p, va, perm);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;	<span class="comment">//check page insert</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">	     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>, *<span class="title">dste</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span> *<span class="keyword">srcpte_t</span> = <span class="literal">NULL</span>, *<span class="keyword">dstpte_t</span>;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">if</span>(srcva &gt;= (<span class="keyword">void</span>*)UTOP </span><br><span class="line">		|| (<span class="keyword">unsigned</span>)srcva % PGSIZE != <span class="number">0</span></span><br><span class="line">		|| dstva &gt;= (<span class="keyword">void</span>*)UTOP</span><br><span class="line">		|| (<span class="keyword">unsigned</span>)dstva % PGSIZE != <span class="number">0</span></span><br><span class="line">		|| (perm &amp; PTE_U) == <span class="number">0</span></span><br><span class="line">		|| (perm &amp; ~PTE_U &amp; ~PTE_P &amp; ~PTE_AVAIL &amp; ~PTE_W) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;	<span class="comment">//check va, check perm</span></span><br><span class="line">	r = envid2env(srcenvid, &amp;srce, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//check srcenvid </span></span><br><span class="line">	r = envid2env(dstenvid, &amp;dste, <span class="number">1</span>); </span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//check dstenvid </span></span><br><span class="line">	p = page_lookup(srce-&gt;env_pgdir, srcva, &amp;<span class="keyword">srcpte_t</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">srcpte_t</span>)	<span class="keyword">return</span> -E_NO_MEM; </span><br><span class="line">	<span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !(*<span class="keyword">srcpte_t</span> &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL; <span class="comment">//check perm betwen src, dst</span></span><br><span class="line">	r = page_insert(dste-&gt;env_pgdir, p, dstva, perm);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//check ptp allocate</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(va &gt; (<span class="keyword">void</span>*)UTOP || (<span class="keyword">unsigned</span>)va % PGSIZE != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL; <span class="comment">//check va</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;	<span class="comment">//check envid</span></span><br><span class="line">	page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PartB-Copy-on-Write-Fork"><a href="#PartB-Copy-on-Write-Fork" class="headerlink" title="PartB Copy-on-Write Fork"></a>PartB Copy-on-Write Fork</h2><p>  fork可以使用写时复制的机制，fork时只map到父进程而不allocate &amp; copy，只有在子进程需要对page进行write操作时，由于read-only出现page fault，kernel会意识到自己访问的是一个写时复制的page，这时才会创建一个真正的副本。<br>  这种机制大大减少了开销。</p>
<h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>  用户级的page fault handler的entry point是保存在环境的Env中的，使用系统调用可以设置这个entry point。<br>  发生user exception时，内核会从用户栈切换到从UXSTACKTOP向下增长的的user exception stack；每个想支持user-level page fault handling的环境都需要通过sys_page_alloc() to allocate own exception stack</p>
<h4 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现sys_env_set_pgfault_upcall系统调用，设置page fault handler的entry point：</span><br><span class="line">Implement the sys_env_set_pgfault_upcall system call.</span><br><span class="line">Be sure to enable permission checking when looking up the environment ID of the target environment,</span><br><span class="line">since this is a &quot;dangerous&quot; system call.</span><br></pre></td></tr></table></figure>
<h4 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实现page_fault_handler，可以保存trap-time环境并切换到exception stack并调用upcall routine</span><br><span class="line"></span><br><span class="line">Implement the code in page_fault_handler in kern/trap.c</span><br><span class="line">required to dispatch page faults to the user-mode handler.</span><br><span class="line">Be sure to take appropriate precautions when writing into the exception stack.</span><br><span class="line">(What happens if the user environment runs out of space on the exception stack?)</span><br></pre></td></tr></table></figure>
<h4 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实现_pgfault_upcall，其可以接受page fault handler调用并在原始错误指令处继续执行。</span><br><span class="line">Implement the _pgfault_upcall routine in lib/pfentry.S</span><br><span class="line">The interesting part is returning to the original point in the user code that caused the page fault.</span><br><span class="line">You&apos;ll return directly there, without going back through the kernel.</span><br><span class="line">The hard part is simultaneously switching stacks and re-loading the EIP.</span><br></pre></td></tr></table></figure>
<h4 id="Exercise11"><a href="#Exercise11" class="headerlink" title="Exercise11"></a>Exercise11</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Finish set_pgfault_handler() in lib/pgfault.c.</span><br></pre></td></tr></table></figure>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><h4 id="Exercise12"><a href="#Exercise12" class="headerlink" title="Exercise12"></a>Exercise12</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现copy-on-write的三个函数</span><br><span class="line">Implement fork, duppage and pgfault in lib/fork.c.</span><br></pre></td></tr></table></figure>
<p>  本题我们可以开始编写<code>fork()</code>，使用fork时我们仅仅将parent所有的页面映射到child，对于那些PTE_W的页面我们给双方都打上PTE_COW标签，不论parent还是child要写这种页面的时候，都会触发<code>page fault handler</code>，用我们自己编写的<code>pgfault()</code>处理这种错误：即时创建PTE_W副本覆盖原来的PTE_COW副本。<br>  代码量有点大，但是练习本身并不是太难，要理解uvpt和uvpd的原理，我们可以通过<code>uvpd[PDX(addr)]</code>和<code>uvpt[PGNUM(addr)]</code>来分别访问地址addr的pde和pte，这是因为我们在创建环境的时候进行了如下的映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br></pre></td></tr></table></figure>
<p>  然后因为<code>uvpt = UVPT</code>，<code>uvpd = UVPD + (UVPD&gt;&gt;12)*4</code>，<code>UVPD = 0xef400000</code>，所以回想之前二级页表的寻址机制，我们很容易就能理解为什么可以通过这两个数组访问页表，<strong>何等巧妙的设计啊！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查error code和页面的PTE_W</span></span><br><span class="line">    <span class="keyword">pte_t</span> pte = uvpt[PGNUM(addr)];</span><br><span class="line">    <span class="keyword">if</span>((err &amp; FEC_WR) == <span class="number">0</span> || (pte &amp; PTE_COW) == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault(): check failed\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即时复制一份页面</span></span><br><span class="line">    <span class="keyword">void</span>* va = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault(): unmap page at addr: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault(): alloc page at PFTEMP: %e"</span>, r);</span><br><span class="line">    <span class="built_in">memcpy</span>(PFTEMP, va, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_unmap(<span class="number">0</span>, va)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault(): unmap page at va: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, PFTEMP, <span class="number">0</span>, va, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault(): map page from PFTEMP to va: %e"</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 权限设置</span></span><br><span class="line">    <span class="keyword">envid_t</span> nowid = sys_getenvid();</span><br><span class="line">    <span class="keyword">void</span>* va = (<span class="keyword">void</span>*)(pn * PGSIZE);</span><br><span class="line">    <span class="keyword">unsigned</span> perm = PGOFF(uvpt[pn]);</span><br><span class="line">    <span class="keyword">if</span>((perm &amp; PTE_W) != <span class="number">0</span> || (perm &amp; PTE_COW) != <span class="number">0</span>) &#123;</span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先将页面从parent -&gt; child，再parent -&gt; parent </span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(nowid, va, envid, va, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"duppage(): mapping from parent to child: %e\n"</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(nowid, va, nowid, va, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"duppage(): remapping of parent: %e\n"</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1: set page fault handler</span></span><br><span class="line">    set_pgfault_handler(&amp;pgfault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2: parent syscall to get a child</span></span><br><span class="line">    <span class="keyword">envid_t</span> chdid = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span>(chdid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork(): sys_exofork: %e"</span>, chdid);</span><br><span class="line">    <span class="keyword">if</span>(chdid == <span class="number">0</span>) &#123;</span><br><span class="line">        thisenv = envs + ENVX(sys_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3: map all the pages</span></span><br><span class="line">    <span class="keyword">envid_t</span> parid = sys_getenvid();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span>((uvpd[PDX(addr)] &amp; PTE_P) != <span class="number">0</span> &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((r = duppage(chdid, PGNUM(addr))) &lt; <span class="number">0</span>)</span><br><span class="line">                panic(<span class="string">"fork(): duppage at %08x: %e"</span>, addr, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_alloc(chdid, (<span class="keyword">void</span>*)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork(): sys_page_alloc at UXSTACKTOP - PGSIZE: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: set page fault handler entrypoint for child</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_env_set_pgfault_upcall(chdid, _pgfault_upcall)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork(): sys_env_set_pgfault_upcall: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5: set status for child</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_env_set_status(chdid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"fork(): sys_env_set_status: %e"</span>, r);</span><br><span class="line">    <span class="keyword">return</span> chdid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PartC-Preemptive-Multitasking-and-IPC"><a href="#PartC-Preemptive-Multitasking-and-IPC" class="headerlink" title="PartC Preemptive Multitasking and IPC"></a>PartC Preemptive Multitasking and IPC</h2><h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><h4 id="Exercise13"><a href="#Exercise13" class="headerlink" title="Exercise13"></a>Exercise13</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Modify kern/trapentry.S and kern/trap.c</span><br><span class="line">to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15.</span><br><span class="line"></span><br><span class="line">Then modify the code in env_alloc() in kern/env.c</span><br><span class="line">to ensure that user environments are always run with interrupts enabled.</span><br><span class="line"></span><br><span class="line">Also uncomment the sti instruction in sched_halt() so that idle CPUs unmask interrupts.</span><br></pre></td></tr></table></figure>
<h4 id="Exercise14"><a href="#Exercise14" class="headerlink" title="Exercise14"></a>Exercise14</h4><h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><h4 id="Exercise15"><a href="#Exercise15" class="headerlink" title="Exercise15"></a>Exercise15</h4>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartA-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="toc-number">2.</span> <span class="toc-text">PartA Multiprocessor Support and Cooperative Multitasking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiprocessor-Support"><span class="toc-number">2.1.</span> <span class="toc-text">Multiprocessor Support</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise1"><span class="toc-number">2.1.1.</span> <span class="toc-text">Exercise1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise2"><span class="toc-number">2.1.2.</span> <span class="toc-text">Exercise2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Question"><span class="toc-number">2.1.3.</span> <span class="toc-text">Question</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise3"><span class="toc-number">2.1.4.</span> <span class="toc-text">Exercise3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise4"><span class="toc-number">2.1.5.</span> <span class="toc-text">Exercise4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise5"><span class="toc-number">2.1.6.</span> <span class="toc-text">Exercise5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Question-1"><span class="toc-number">2.1.7.</span> <span class="toc-text">Question</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Round-Robin-Scheduling"><span class="toc-number">2.2.</span> <span class="toc-text">Round-Robin Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise6"><span class="toc-number">2.2.1.</span> <span class="toc-text">Exercise6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Calls-for-Environment-Creation"><span class="toc-number">2.3.</span> <span class="toc-text">System Calls for Environment Creation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise7"><span class="toc-number">2.3.1.</span> <span class="toc-text">Exercise7</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartB-Copy-on-Write-Fork"><span class="toc-number">3.</span> <span class="toc-text">PartB Copy-on-Write Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#User-level-page-fault-handling"><span class="toc-number">3.1.</span> <span class="toc-text">User-level page fault handling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise8"><span class="toc-number">3.1.1.</span> <span class="toc-text">Exercise8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise9"><span class="toc-number">3.1.2.</span> <span class="toc-text">Exercise9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise10"><span class="toc-number">3.1.3.</span> <span class="toc-text">Exercise10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise11"><span class="toc-number">3.1.4.</span> <span class="toc-text">Exercise11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementing-Copy-on-Write-Fork"><span class="toc-number">3.2.</span> <span class="toc-text">Implementing Copy-on-Write Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise12"><span class="toc-number">3.2.1.</span> <span class="toc-text">Exercise12</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PartC-Preemptive-Multitasking-and-IPC"><span class="toc-number">4.</span> <span class="toc-text">PartC Preemptive Multitasking and IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clock-Interrupts-and-Preemption"><span class="toc-number">4.1.</span> <span class="toc-text">Clock Interrupts and Preemption</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise13"><span class="toc-number">4.1.1.</span> <span class="toc-text">Exercise13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise14"><span class="toc-number">4.1.2.</span> <span class="toc-text">Exercise14</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inter-Process-communication-IPC"><span class="toc-number">4.2.</span> <span class="toc-text">Inter-Process communication (IPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise15"><span class="toc-number">4.2.1.</span> <span class="toc-text">Exercise15</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/07/02/mit6-828A10/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/07/02/mit6-828A10/&text=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/07/02/mit6-828A10/&is_video=false&description=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.828:assignment10:LAB4抢占式多任务&body=Check out this article: http://yoursite.com/2019/07/02/mit6-828A10/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/07/02/mit6-828A10/&title=MIT6.828:assignment10:LAB4抢占式多任务"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/07/02/mit6-828A10/&name=MIT6.828:assignment10:LAB4抢占式多任务&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menú</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Compartir</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Cap amunt</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 jihandong
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
